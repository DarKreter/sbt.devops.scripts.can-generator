IF_N_DEF_STRING = "#ifndef F1XX_PROJECT_TEMPLATE_LIB_SBT_SDK_F1XX_SBT_SDK_SYSTEM_{}_H"
DEFINE_STRING = "#define F1XX_PROJECT_TEMPLATE_LIB_SBT_SDK_F1XX_SBT_SDK_SYSTEM_{}_H"
INCLUDE_STRING_LIB = "#include <cstdint>"
WARNING_AND_FILE_DESCRIPTION = "/**\
 * !!!WARNING!!!\n\
 * This file is autogenerated, any changes will not be retained after next\n\
 * generation.\n\
 *\n\
 * @brief In this file are Source, Param, Group, Message ID definitions.\n\
 */"
CAN_ID_NAMESPACE_BEGIN_STRING = "namespace SBT::System::Comm::CAN_ID {"
CAN_ID_NAMESPACE_END_STRING = "} // namespace SBT::System::Comm::CAN_ID"

MESSAGE_NAMESPACE_BEGIN_STRING = "namespace Message {"
MESSAGE_NAMESPACE_END_STRING = "} // namespace Message"

ENUM_CLASS_CAN_SOURCE_ID_BEGIN = "enum class Source : uint8_t {\n\
\tDEFAULT = 0x00,"
ENUM_CLASS_CAN_PARAM_ID_BEGIN = "enum class Param : uint16_t {\n\
\tDEFAULT = 0x000,"
ENUM_CLASS_CAN_GROUP_ID_BEGIN = "enum class Group : uint8_t {\n\
\tDEFAULT = 0x00,"
MESSAGE_t_STRUCT_DEFINITION = "struct Message_t {\n\
\tuint8_t priority;\n\
\tParam paramID;\n\
\tGroup group;\n\
};"

class HGenerate:

    def __init__(self, name):
        self.name = name

    @staticmethod
    def id_range_loop(json_object, i, rng, hexSize):
        max_id = int(json_object[rng][i]['MaxID'], 16)
        curr_id = int(json_object[rng][i]['MinID'], 16)
        adresses = []
        while max_id >= curr_id:
            adresses.append(hex(curr_id))
            curr_id = curr_id + 1
        x = 0
        dict_address = []
        for j in range(len(adresses)):
            x += 1
            help_str = "{} = {}".format(x, "0x{0:0{1}X}".format(int(adresses[j], 16), hexSize))
            dict_address.append(json_object[rng][i]["Name"].replace("<x>", help_str))
        return dict_address

    @staticmethod
    def explode_IDs_into_mess_var(json_object, param):
        max_id = int(param['MaxID'], 16)
        curr_id = int(param['MinID'], 16)
        adresses = []
        while max_id >= curr_id:
            adresses.append(hex(curr_id))
            curr_id = curr_id + 1
        x = 0
        dict_address = []
        for j in range(len(adresses)):
            x += 1
            dict_address.append(param["Name"].replace("<x>", str(x)))
        return dict_address
    

    def write(self, file, text, newLinesQuantity):
        file.write(text)
        file.write("\n" * newLinesQuantity)

    def write_to_file(self, json_object):
        with open(self.name, "w") as file:
            self.write(file, IF_N_DEF_STRING.format(self.name[0:self.name.index('.')]), 1)
            self.write(file, DEFINE_STRING.format(self.name[0:self.name.index('.')]), 2)
            self.write(file, INCLUDE_STRING_LIB, 2)
            self.write(file, WARNING_AND_FILE_DESCRIPTION, 2)
            self.write(file, CAN_ID_NAMESPACE_BEGIN_STRING, 2)
            
            ID_types = [("SourceIDs", ENUM_CLASS_CAN_SOURCE_ID_BEGIN, 2), 
                        ("ParamIDs", ENUM_CLASS_CAN_PARAM_ID_BEGIN, 3),
                        ("GroupIDs", ENUM_CLASS_CAN_GROUP_ID_BEGIN, 2),]
            
            for (ID_type, ENUM_CLASS_BEGIN, hexLength) in ID_types:
                self.write(file, ENUM_CLASS_BEGIN, 1)
                # for loop
                for i in range(len(json_object[ID_type])):
                    if 'ID' not in json_object[ID_type][i]:
                        generator = self.id_range_loop(json_object, i, ID_type, hexLength)

                        for j in range(len(generator)):
                                self.write(file, "\t{},".format(generator[j]), 1)
                                
                    else:
                        self.write(file, "\t{} = {}".format(json_object[ID_type][i]["Name"], 
                                                        json_object[ID_type][i]['ID']), 0)
                        self.write(file, ",", 1)
                        
                                            
                self.write(file, "\tUNKNOWN\n};", 2)

            self.write(file, MESSAGE_t_STRUCT_DEFINITION, 2)
            
            self.write(file, MESSAGE_NAMESPACE_BEGIN_STRING, 2)
            for Param in json_object["ParamIDs"]:
                if 'ID' not in Param:
                    generator = self.explode_IDs_into_mess_var(json_object, Param)

                    for j in range(len(generator)):
                        self.write(file, "constexpr Message_t {} =  {{{}, Param::{}, Group::{}}};".format(
                                        generator[j], Param["Priority"], generator[j], Param["Group"]), 2)
                        
                else:
                    self.write(file, "constexpr Message_t {} =  {{{}, Param::{}, Group::{}}};".format(
                    Param["Name"], Param["Priority"], Param["Name"], Param["Group"]), 2)
                
            self.write(file, MESSAGE_NAMESPACE_END_STRING, 2)
            
            self.write(file, CAN_ID_NAMESPACE_END_STRING, 2)
            self.write(file, "#endif", 0)
